<html>
<body>

</body>
</html>
<body id='bod' onload="load()">

<style>
    body {
        display: flex;
        justify-content: flex-end;
        flex-direction: column-reverse;
    }

</style>
<head>
    <canvas id="canvBG"></canvas>
    <canvas id="canvPlayer"></canvas>
    <style type="text/css">
        body {
            margin: 0;
        }

        #canvBG {
            background-color: #000;
            z-index: -1;
            position: fixed;
            width: 100vw;
            height: 100vh;
            margin: 0px;
        }

        #canvPlayer {
            background-color: transparent;
            z-index: 0;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }


    </style>
    <script type="text/javascript">

        /* EVENT LISTENERS */




        const STATE = {
            //fireTimer
            //hasWeaponX
            moving: false,
            moveSpeed: 5,
            playerX: 120,

            //health
            //points
            //
        }

        window.addEventListener("keydown", function (ev) {
            NECK.endY = handleInput(ev.keyCode) * 100;

            let xDelta = handleMove(ev.keyCode) * STATE.moveSpeed;
            if (xDelta !== 0) {
                STATE.moving = true;
                STATE.playerX += xDelta;
            }



        })
        window.addEventListener("keypress", function (ev) {


            if (ev.keyCode === 32) {
                head.fireTimer++;
                head.fillColor(head.fireTimer)


                if (head.fireTimer > 30) {
                    head.fireOn=true;
                }

            }
        })

        window.addEventListener("keyup", function (ev) {
            console.log(ev.keyCode)
            STATE.moving = !STATE.moving;

            if (ev.keyCode === 32) {
                head.fireOn = false;
                head.fireTimer = 0;
                head.color = "white"
            }

        })

        const canvasPlayer = document.getElementById("canvPlayer")
        const canvasBG = document.getElementById("canvBG")
        const ctxPlayer = canvasPlayer.getContext("2d");
        const ctxBG = canvasBG.getContext("2d");

        ctxPlayer.lineCap = "round"

        const canvi = [canvasPlayer, canvasBG]
        const ctxes = [ctxPlayer, ctxBG]
        /* DECLARATIONS*/
        const GAME = {
            pitchRange: 10,
            FPS: 60,
            endY: 800
            //breakNeckSpeed? LLOLOLOL ROFL HELICOPTER ILLUMINATE CONFIRMED HOAX O@2
        }

        const NECK = {
            speed: 6,
            rectCount: 10,
            startY: 200,
            endY: 600
        }
        const Rect = class {
            constructor(presets) {
                //there is no startY ... set that were you use the class
//                this.numberInChain = numberInChain //1 = 1st from the bottom going up
                this.y = 200;
                this.goalY = 200;
                this.w = 100;
                this.h = 20;
                this.x = 150;
                this.color = "red";
                this.localRotation = 10; //gets inverted @ rotateFN ==> prefer clockwise
                Object.assign(this, presets) //merge into what's left
            }

            tick() {

            }

            setGoalY(data) {
                const {start, end, count} = data;
                const percY = this.numberInChain / count;
                this.goalY = start + (end - start) * percY;
                return this.goalY;
            }

            adjustY(inSteps) { //will approach, but not reach...abschwaechende curve
                const delta = this.goalY - this.y; //linear: exchange currentY here with memory of y when it started
                this.y += delta / inSteps;
                return this.y;
            }

            moveTo() {

            }

            incrementPos() {

            }

            localRotate(ctx = ctxPlayer) {
                ctx.translate(this.x, this.y)
                ctx.rotate(-this.localRotation * Math.PI / 180)
                ctx.translate(-(this.x), -(this.y))
//                drawRect(box, ctxPlayer, playerX + 200);
            }

            blueprint() {
                const {x, y, w, h} = this;
                const blueprint = [{
                    method: "rect",
                    vertices: [
                        x - w / 2,
                        y - h / 2,
                        w,
                        h
                    ]
                }]
                return blueprint;
            }

            modifyDNA() {
            }

            executeBP(blueprint, ctx = ctxPlayer) {
                const bp = blueprint.slice();

                const commands = bp.map(instruct => function () {
                    return ctx[instruct.method](...instruct.vertices)
                })
                return commands;
            }

            drawMe(ctx = ctxPlayer, padding = 1.1) {
                this.drawFns = this.executeBP(this.blueprint())
                ctx.beginPath();
                ctx.fillStyle = NumberToHSLa(yToPitch(this.y, GAME.endY, NECK.startY, GAME.pitchRange));
                ctx.save();

                this.localRotate();

                this.drawFns.map(f => f());

                ctx.fill();
                ctx.closePath();
                ctx.restore()
            }
        }

        class Head extends Rect {
            constructor(presets, canvasContext) {
                super();
                this.ctx = canvasContext;
                this.fireTimer = 0;
                this.fireOn = false; //TODO --> STORE not state
                Object.assign(this, presets);

            }
            drawMe(ctx = this.ctx){ //override
                const {x, y, w, h, mouthHeight} = this;
                ctx.beginPath();
                ctx.moveTo(x - w / 2, y - h / 2)
                ctx.lineTo(x - w / 3, y)
                ctx.lineTo(x - w / 2, y + h / 2)
                ctx.lineTo(x + w / 2, y + h / 1.5)
                ctx.lineTo(x + w / 2, y - h / 1.5)
                ctx.fillStyle = this.color;
                //nose
                ctx.moveTo(x + w / 2, y - 12)
                ctx.lineTo(x + w / 2 + 15, y - 10)
                ctx.lineTo(x + w / 2, y + 15)

                ctx.fill()

                //eye
                ctx.fillStyle = "black"
                ctx.fillRect(x, y, 20, 20);

                ctx.fillRect(x + w / 4, y - 30 - mouthHeight / 2, w / 4, mouthHeight)
            }
            mouthAnim(time) {
                return 15 * (Math.abs(Math.sin(Math.pow(time % 200 / 25, 1.5)) * 1.5))
            }
            fillColor(percent) {
                this.color = NumberToHSLa(yToPitch(this.y, GAME.endY, NECK.startY, GAME.pitchRange),'100%', `${100 - percent}%`);
            }
            fire(ctx = this.ctx) {
                const that = this;
                this.fireTimer+= 1 + that.fireTimer/10;
                const mouth = {
                    x: this.x + this.w / 3,
                    y: this.y - this.h / 2.3,
                }
                const data = {
                    x: this.x + this.w / 2,

                    h: 40,
                    w: 80,
                    color: 'blue'
                }

                const colY = yToPitch(that.y, GAME.endY, NECK.startY, GAME.pitchRange);


                function spit(mouthX, mouthY, h) {
                    ctx.beginPath();
                    const w = data.w;
                    ctx.moveTo(mouthX, mouthY);
                    ctx.lineTo(mouthX + w / 2, mouthY - h / 7);
                    ctx.lineTo(mouthX + w / 2, mouthY + h / 7);
                    ctx.fillStyle = NumberToHSLa(colY-0.5 + Math.random());
                    ctx.closePath()
                    ctx.fill();
                }

                let rounds = Math.floor(that.fireTimer / 10)

                for (let i = 0; i < rounds; i++) {
                    spit(mouth.x + 20 * i, mouth.y, data.h + i * 40)
                }

                if (that.fireTimer > 100) {
                    that.fireTimer = 0;
                    that.fireOn = false;
                }
                this.mouthHeight = this.mouthAnim(this.fireTimer) + 2;

            }

        }
        const head = new Head({
            x: 150,
            y: 600,
            w: 90,
            h: 70,
            color: "white",
            mouthHeight: 5
        }, ctxPlayer);

//        const head = new Rect({
//            x: 150,
//            y: 600,
//            w: 90,
//            h: 70,
//            color: "white",
//            mouthHeight: 5
//        });
//
//        head.drawMe = function (ctx = ctxPlayer) { //override
//            const {x, y, w, h, mouthHeight} = this;
//            ctx.beginPath();
//            ctx.moveTo(x - w / 2, y - h / 2)
//            ctx.lineTo(x - w / 3, y)
//            ctx.lineTo(x - w / 2, y + h / 2)
//            ctx.lineTo(x + w / 2, y + h / 1.5)
//            ctx.lineTo(x + w / 2, y - h / 1.5)
//            ctx.fillStyle = this.color;
//            //nose
//            ctx.moveTo(x + w / 2, y - 12)
//            ctx.lineTo(x + w / 2 + 15, y - 10)
//            ctx.lineTo(x + w / 2, y + 15)
//
//            ctx.fill()
//
//            //eye
//            ctx.fillStyle = "black"
//            ctx.fillRect(x, y, 20, 20);
//
//            ctx.fillRect(x + w / 4, y - 30 - mouthHeight / 2, w / 4, mouthHeight)
//        };
//
//
//        head.mouthAnim = function(time) {
//            return 15 * (Math.abs(Math.sin(Math.pow(time % 200 / 25, 1.5)) * 1.5))
//        }
//        head.fillColor = function (percent) {
//            head.color = NumberToHSLa(yToPitch(this.y, GAME.endY, NECK.startY, GAME.pitchRange),'100%', `${100 - percent}%`);
//        }
//
//
//        head.fire = function (ctx = ctxPlayer) {
//            const that = this;
//            this.fireTimer+= 1 + that.fireTimer/10;
//            const mouth = {
//                x: this.x + this.w / 3,
//                y: this.y - this.h / 2.3,
//            }
//            const data = {
//                x: this.x + this.w / 2,
//
//                h: 40,
//                w: 80,
//                color: 'blue'
//            }
//
//            const colY = yToPitch(that.y, GAME.endY, NECK.startY, GAME.pitchRange);
//
//
//            function spit(mouthX, mouthY, h) {
//                ctx.beginPath();
//                const w = data.w;
//                ctx.moveTo(mouthX, mouthY);
//                ctx.lineTo(mouthX + w / 2, mouthY - h / 7);
//                ctx.lineTo(mouthX + w / 2, mouthY + h / 7);
//                ctx.fillStyle = NumberToHSLa(colY-0.5 + Math.random());
//                ctx.closePath()
//                ctx.fill();
//            }
//
//            let rounds = Math.floor(that.fireTimer / 10)
//
//            for (let i = 0; i < rounds; i++) {
//                spit(mouth.x + 20 * i, mouth.y, data.h + i * 40)
//            }
//
//            if (that.fireTimer > 100) {
//                that.fireTimer = 0;
//                that.fireOn = false;
//            }
//            head.mouthHeight = this.mouthAnim(this.fireTimer) + 2;
//
//        }


        const body = new Rect({
            numberInChain: 0.5,
            w: 100,
            h: 75,
            color: "white",
            y: 200

        });

        const legL = {
            w: body.w,
            y: 120,
            h: 120,
            maxh: 120,
            up: true,
            move(){
                if (this.h < 120) {
                    this.up = false
                }
                else if (this.h > 180){
                    this.up = true;
                }
                if (this.up) {
                    this.h -= 4* (this.maxh/(this.h));
                }
                else if (!this.up) {
                    this.h+=2 + Math.random()*2;
                }

            }
        }
        const legR = Object.assign({}, legL);
        legR.w = legR.w * -1 //direction shift
        legR.moveWith = function (otherLeg) {
            this.up = !otherLeg.up;
            this.move();
        }


        flies = []
        let necktangles = [];
        necktangles.length = NECK.rectCount;
        necktangles.fill(1)
        necktangles = necktangles.map((e, i) => new Rect({numberInChain: i}))
        let playerX = 150;

        //TODO abstract value giver FN

        /*ACTION*/
        let timer = 0;
        const loop = function () {
            timer++;
            requestAnimationFrame(loop);

            ctxPlayer.clearRect(0, 0, window.innerWidth, window.innerHeight)
            for (let rect of necktangles) {
                rect.setGoalY({start: NECK.startY, end: NECK.endY, count: NECK.rectCount})
                rect.adjustY(10);
                rect.h = ((NECK.endY - NECK.startY) / NECK.rectCount)
                ctxPlayer.save()
//                ctxPlayer.translate(playerX, rect.y)
                rect.localRotation = Math.random() * 30;
                rect.x = STATE.playerX

                rect.drawMe();
//                drawRect(rect, ctxPlayer)
                ctxPlayer.restore();
//                ctxPlayer.rotate(-rect.degRot * Math.PI / 180)
            }

            head.drawMe();

            if (head.fireOn) {
                head.fire();
            }

            head.x = STATE.playerX;
            body.x = STATE.playerX;

            lastNeckBone = necktangles[necktangles.length - 1]
            head.y = lastNeckBone.y + lastNeckBone.h / 2 + head.h / 2;  //the last neck

            firstBone = necktangles[0];
            body.y = firstBone.y - firstBone.h / 2.4;
            drawTrapezoid(body, ctxPlayer)
//            drawRect(head, ctxPlayer)

            legL.y = body.y;
            legR.y = body.y;

            if (STATE.moving) {
                legR.moveWith(legL)

                legL.move();
            }
            else {
                legL.h = legL.y;
                legR.h = legL.y;

            }

            drawTriangle(legL, ctxPlayer)
            drawTriangle(legR, ctxPlayer)

        }

        function load() {

            canvasBG.width = window.innerWidth;
            canvasBG.height = window.innerHeight;
            canvasPlayer.width = window.innerWidth;
            canvasPlayer.height = window.innerHeight;
//            ctxPlayer.translate(0, canvasPlayer.height);
//            ctxPlayer.scale(1, -1);

            //
            ctxPlayer.setTransform(1, 0, 0, -1, 0, canvasPlayer.height) //this way ==
            //--that way :
            ctxBG.translate(0, canvasBG.height);
            ctxBG.scale(1, -1);
            //

            ctxPlayer.fillStyle = 'white';
            ctxPlayer.rect(0, 0, 100, 100)
            ctxPlayer.fill()


            for (let i = 0; i < necktangles.length; i++) { //copies class but NOT by REFERENCE!! otherwise huge fuckup
                let rect = necktangles[i]
                const rnd = Math.random() * 3;
                rect.degRot = rnd;
                rect.y = NECK.startY + rect.numberInChain * rect.h;
                rect.goalY = rect.y;
                rect.color = NumberToHSLa(yToPitch(rect.y, GAME.endY, NECK.startY, GAME.pitchRange));
                rect.w = rect.w - (5 * rect.numberInChain); //calcRectWidth
                rect.drawMe();
            }
            loop()
        }

        function yToPitch(y, endY, startY, pitchR) {
            const units = (endY - startY) / pitchR;
            return (y - startY) / units;
        }

        //NECK.endY =
        function pitchToY(pitch) {
            return pitch * ((window.innerHeight - NECK.startY) / GAME.pitchRange) //-- one NeckUnit
        }


        const handleMove = function(inputCode) {
            if (inputCode === 68 || inputCode === 39) {
                return 1;
            }
            else if (inputCode === 65 || inputCode === 37) {
                return -1;
            }
            else {
                return 0;
            }
        }
        /* UTILITY FUNCTIONS */
        const handleInput = function (inputCode) {
            switch (inputCode) {
                case 49:
                    return 1;

                case 50:
                    return 2;
                case 51:
                    return 3;

                case 52:
                    return 4;

                case 53:
                    return 5;

                case 54:
                    return 6;

                case 55:
                    return 7;

                case 56:
                    return 8;

                case 57:
                    return 9;

                default:
                    return NECK.endY/100;
            }

        }

        const drawTriangle = function (data, ctx, x = STATE.playerX) {
            ctx.beginPath();
            const {w, y, h} = data;
            ctx.moveTo(x - w / 2.4, y);
            ctx.lineTo(x, y);
            ctx.lineTo(x - w / 3, y - h);
            ctx.fillStyle = data.color || "white";
            ctx.fill();
        }

        const drawTrapezoid = function (data, ctx, x = STATE.playerX) {
            ctx.beginPath();
            const {y, w, h} = data;
            ctx.moveTo(x - w / 2, y);
            ctx.lineTo(x + w / 2, y);
            ctx.lineTo(x + w / 5, y - h);
            ctx.lineTo(x - w / 5, y - h);
            ctx.fillStyle = "white";
            ctx.fill();
        }


        const gameUnitsToPixel = function (number) {
            return number * window.innerWidth / 100
//            else  if (dimension === "h") {
//                return number* window.innerHeight/100
//            }
//            else {
//                throw UserException("No Dimension specified")
//            }
        }

        function NumberToHSLa(number, s = "100%", l = "60%", a = 1) { //HSL is more intuitive then RGB s=100, l =60;
            let num = number;
            if (number > 12) {
                num = number % 12;
            }

            let h = 360 - num * 360 / 12 + 60; //Hue goes gradually around (COUNTERCLOCK) the wheel at pitch '6' => 180deg
            if (h == 360) {
                h = 0;
            }

            return "hsla" + "(" + h + "," + s + "," + l + "," + a + ")";
        }

    </script>
</head>
</body>

