<html>
<body>

</body>
</html>
<body id='bod' onload="load()">

<style>
    body {
        display: flex;
        justify-content: flex-end;
        flex-direction: column-reverse;
    }

</style>
<head>
    <canvas id="canvBG"></canvas>
    <canvas id="canvPlayer"></canvas>
    <style type="text/css">
        body {
            margin: 0;
        }

        #canvBG {
            background-color: #000;
            z-index: -1;
            position: fixed;
            width: 100vw;
            height: 100vh;
            margin: 0px;
        }

        #canvPlayer {
            background-color: transparent;
            z-index: 0;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }


    </style>

    <script src="./Monophonics.js"></script>
    <script type="text/javascript">

        /* EVENT LISTENERS */
        const STATE = {
            //fireTimer
            //hasWeaponX
            moving: false,
            moveSpeed: 5,
            playerX: 120,
            fireOn: false,
            loadingFire: false,

            NECK: {
                speed: 6,
                rectCount: 12,
                startY: 200,
                endY: 600
            },
            //health
            //points
            //so 1 unit always equals same pixels
            scaler: window.innerWidth / 100,
        }

        window.addEventListener("keydown", function (ev) {
            if (ev.keyCode === 32) {
                STATE.loadingFire = true;
            } else {

                let xDelta = handleMove(ev.keyCode) * STATE.moveSpeed;
                if (xDelta !== 0) {
                    STATE.moving = true;
                    STATE.playerX += 2 * xDelta;
                }
                else {
                    STATE.NECK.endY = STATE.NECK.startY + handleInput(ev.keyCode) * (GAME.endY - STATE.NECK.startY) / 10;
                }
            }

        });

        window.addEventListener("keyup", function (ev) {
            if (ev.keyCode === 32) {
                STATE.loadingFire = false;
                STATE.fireOn = false;
                head.fireTimer = 0;
                head.color = "white"
            }
            if (handleMove(ev.keyCode) !== 0) {
                STATE.moving = false;
            }
        })

        const canvasPlayer = document.getElementById("canvPlayer")
        const canvasBG = document.getElementById("canvBG")
        const ctxPlayer = canvasPlayer.getContext("2d");
        const ctxBG = canvasBG.getContext("2d");
        ctxPlayer.lineCap = "round";
        ctxBG.lineCap = "round";

        /* DECLARATIONS*/
        const GAME = {
            pitchRange: 12,
            FPS: 60,
            endY: window.innerHeight,
            baseMidi: 48,
            currentMidi: 52
            //breakNeckSpeed? LLOLOLOL ROFL HELICOPTER ILLUMINATE CONFIRMED HOAX O@2
        };

        const Rect = class {
            constructor(presets, canvasContext) {
                //there is no startY ... set that were you use the class
//                this.numberInChain = numberInChain //1 = 1st from the bottom going up
                this.ctx = canvasContext;
                this.y = 200;
                this.goalY = 200;
                this.w = 100;
                this.h = 20;
                this.x = 150;
                this.color = "red";
                this.localRotation = -5 + Math.random() * 10; //gets inverted @ rotateFN ==> prefer clockwise

                Object.assign(this, presets) //merge into what's left
            }

            tick(STATE) {
                const S = Object.assign({}, STATE)
                const {playerX, NECK, gameUnitsToPixel} = S;
                this.adjust(Object.assign({}, NECK));
                this.x = playerX;

                if (this.goalY / this.y < 0.97 || this.goalY / this.y > 1.03) { //if the neck is moving
                    this.localRotation = -10 + Math.random() * 30;
                }
                this.drawMe()

                return this;
            }

            setGoalY(start, end, count) {
                const percY = this.numberInChain / count;
                this.goalY = start + (end - start) * percY;
                return this.goalY;
            }

            adjustY(inSteps) { //will approach, but not reach...abschwaechende curve
                const delta = this.goalY - this.y; //linear: exchange currentY here with memory of y when it started
                this.y += delta / inSteps;
                return this.y;
            }

            adjust(neck) {
                const {startY, endY, rectCount} = neck;
                this.setGoalY(startY, endY, rectCount)
                this.adjustY(10);
                this.h = ((endY - startY) / rectCount)
            }

            blueprint() {
                const {x, y, w, h} = this;
                return [{
                    method: "rect",
                    vertices: [
                        x - w / 2,
                        y - h / 2,
                        w,
                        h
                    ]
                }]
            }

            localRotate(ctx = this.ctx) {
                ctx.translate(this.x, this.y)
                ctx.rotate(-this.localRotation * Math.PI / 180)
                ctx.translate(-(this.x), -(this.y))
//                drawRect(box, ctxPlayer, playerX + 200);
            }

            drawMe(ctx = this.ctx, padding = 1.1) {
                ctx.beginPath();
                ctx.fillStyle = NumberToHSLa(yToPitch(this.y, GAME.endY, STATE.NECK.startY, GAME.pitchRange));
                ctx.save();

                this.localRotate();

                this.blueprint().map(instruct => ctx[instruct.method](...instruct.vertices))

                ctx.fill();
                ctx.closePath();
                ctx.restore()
            }
        }

        class Head
            extends Rect {
            constructor(presets, canvasContext) {
                super();
                this.ctx = canvasContext;
                this.fireTimer = 0;
                Object.assign(this, presets);
            }

            tick(STATE) {
                const {playerX, fireOn} = STATE;
                const {neckT} = STATE.NECK;

                const lastNeckBone = neckT[neckT.length - 1];

                this.y = lastNeckBone.y + lastNeckBone.h / 2 + this.h / 2;
                this.x = playerX;

                this.fillColor(this.fireTimer)

                this.mouthHeight = this.mouthAnim(this.fireTimer) + 2;
                this.drawMe();

                if (fireOn) {
                    this.fire()
                }

            }

            drawMe(ctx = this.ctx) { //override
                const {x, y, w, h, mouthHeight} = this;
                ctx.beginPath();
                ctx.moveTo(x - w / 2, y - h / 2)
                ctx.lineTo(x - w / 3, y)
                ctx.lineTo(x - w / 2, y + h / 2)
                ctx.lineTo(x + w / 2, y + h / 1.5)
                ctx.lineTo(x + w / 2, y - h / 1.5)
                ctx.fillStyle = this.color;
                //nose
                ctx.moveTo(x + w / 2, y - 12)
                ctx.lineTo(x + w / 2 + 15, y - 10)
                ctx.lineTo(x + w / 2, y + 15)

                ctx.fill()

                //eye
                ctx.fillStyle = "black"
                ctx.fillRect(x, y, 20, 20);

                ctx.fillRect(x + w / 4, y - 30 - mouthHeight / 2, w / 4, mouthHeight)

                //text
                ctx.fillStyle = "white";
                ctx.fillText(GAME.note, x-w/4, y-h/6);
            }

            mouthAnim(time) {
                return 15 * (Math.abs(Math.sin(Math.pow(time % 200 / 25, 1.5)) * 1.7))
            }

            fillColor(percent) {
                if (this.fireTimer !== 0) {
                    this.color = NumberToHSLa(yToPitch(this.y, GAME.endY, STATE.NECK.startY, GAME.pitchRange), '100%', `${100 - percent}%`);
                }
                else {
                    this.color = "white"
                }
            }

            spit(mouth, data, ctx = this.ctx) { //should draw after drawME!! <<<< to see otherwise mouth clips the flames off
                const colY = yToPitch(this.y, GAME.endY, STATE.NECK.startY, GAME.pitchRange);
                ctx.beginPath();
                const {w, h} = data;
                const {x, y} = mouth;
                ctx.moveTo(x, y);
                ctx.lineTo(x + w / 2, y - h / 7);
                ctx.lineTo(x + w / 2, y + h / 7);
                ctx.fillStyle = NumberToHSLa(colY - 0.5 + Math.random());
                ctx.closePath()
                ctx.fill();
            }

            fire() {
                this.fireTimer += 1 + this.fireTimer / 10;
                const mouth = {
                    x: this.x + this.w / 3,
                    y: this.y - this.h / 2.3,
                }
                const flameData = {h: 40, w: 80}

                let rounds = Math.floor(this.fireTimer / 10)

                for (let i = 0; i < rounds; i++) {
                    const m = Object.assign({}, mouth)
                    const d = Object.assign({}, flameData)
                    m.x += 20 * i;
                    d.h += 40 * i;
                    this.spit(m, d)
                }
                if (this.fireTimer > 100) {
                    this.fireTimer = 0;
                    this.fireOn = false;
                }
            }
        }

        const head = new Head({
            x: 150,
            y: 600,
            w: 90,
            h: 70,
            color: "white",
            mouthHeight: 5
        }, ctxPlayer);

        const body = new Rect({
            numberInChain: 0.5,
            w: 100,
            h: 75,
            color: "white",
            y: 200,
            tick(STATE) {
                const {playerX} = Object.assign({}, STATE);
                const {neckT} = Object.assign({}, STATE.NECK);
                this.x = playerX;
                this.y = neckT[0].y - neckT[0].h / 2.4; //firstNeckBone

                this.drawMe();
            },
            drawMe(ctx = this.ctx) {
                ctx.beginPath();
                const {x, y, w, h} = this;
                ctx.moveTo(x - w / 2, y);
                ctx.lineTo(x + w / 2, y);
                ctx.lineTo(x + w / 5, y - h);
                ctx.lineTo(x - w / 5, y - h);
                ctx.fillStyle = "white";
                ctx.fill();
            }
        }, ctxPlayer);

        const legL = {
            ctx: ctxPlayer,
            w: body.w,
            y: 120,
            h: 120,
            maxh: 120,
            up: true,
            tick(STATE, otherLeg) {
                const {legsY, playerX} = Object.assign({}, STATE);
                this.y = legsY;
                this.x = playerX;

                if (STATE.moving && otherLeg !== undefined) {
                    this.moveWith(otherLeg)
                }
                else if (STATE.moving && otherLeg === undefined) {
                    this.move();
                }
                else {
                    this.h = this.y;
                }
                this.drawMe()
            },
            drawMe(ctx = this.ctx) {
                ctx.beginPath();
                const {x, w, y, h} = this;
                ctx.moveTo(x - w / 2.4, y);
                ctx.lineTo(x, y);
                ctx.lineTo(x - w / 3, y - h);
                ctx.fillStyle = "white";
                ctx.fill();
            },
            moveWith(otherLeg) {
                this.up = !otherLeg.up;
                this.move();
            },
            move() {
                if (this.h < 120) {
                    this.up = false
                }
                else if (this.h > 180) {
                    this.up = true;
                }
                if (this.up) {
                    this.h -= 4 * (this.maxh / (this.h));
                }
                else if (!this.up) {
                    this.h += 2 + Math.random() * 2;
                }
            }
        }

        const legR = Object.assign({}, legL);
        legR.w = legR.w * -1 //direction shift

        let flies = [{
            x: 500,
            y: 500
        }]

        let timer = 1;
        let necktangles = [];
        necktangles.length = STATE.NECK.rectCount;
        necktangles.fill(1)
        necktangles = necktangles.map((e, i) => new Rect({numberInChain: i}, ctxPlayer))

        /*ACTION*/
        let pitchdetect;
        let roundBuffer = [];
        roundBuffer.length = 10;
        roundBuffer.fill(Math.random())

        const loop = function () {
            requestAnimationFrame(loop);
            timer++;


            /* SOUND STUFF */
            pitchdetect.updateEnergyValues();
            const winnerBin = pitchdetect.normBinIdx;
            const midi = Number(pitchdetect.binToMidi(winnerBin).toFixed(2));
            GAME.currentMidi = midi;
            const pitchHeight = midi - GAME.baseMidi;
            GAME.pitchRel = pitchHeight;
            const silence = -1 - GAME.baseMidi;
            const roundedPitch = Math.round(pitchHeight);
            GAME.note = pitchdetect.midiToNoteName(midi) || ""


            roundBuffer.push(roundedPitch);
            if (roundBuffer.length > 9) {
                roundBuffer.shift();
            }
            if (roundBuffer.every(e => e === roundedPitch) && roundBuffer[0] !== silence) {
                STATE.loadingFire = true;
            }
            else {
                STATE.loadingFire = false;
                head.fireTimer = 0;
                STATE.fireOn = false;
            }

            if (pitchHeight > 0 && pitchHeight <= GAME.pitchRange) {
                STATE.NECK.endY = pitchToY(pitchHeight)
            }
            // ---------------------------


            ctxPlayer.clearRect(0, 0, window.innerWidth, window.innerHeight);

            ctxBG.fillStyle = "hsla(255, 100%, 00%, 0.10)";

            if (STATE.loadingFire) {
                head.fireTimer++;
            }
            if (head.fireTimer > 30) {
                STATE.fireOn = true;
            }

            necktangles.forEach(rect => rect.tick(STATE))

            STATE.NECK.neckT = necktangles;

            head.tick(STATE);
            body.tick(STATE);

            const legsY = body.y;
            legL.tick(Object.assign({legsY: legsY}, STATE), undefined);
            legR.tick(Object.assign({legsY: legsY}, STATE), legL);

            flies.map(f => drawFly(f, timer))
            flies.forEach(fly => fly.x = fly.x - 1)

            if (STATE.fireOn) {
                flies.forEach(f => {
                    if (isColliding(head, f)) {
                        console.log("COLLISON")
                        f.isDead = true;
                        ctxBG.fillStyle = "white";

                        flies = flies.filter(f => !f.isDead)
                    }
                })
            }
            //this is later in the loop for user to notice
            ctxBG.fillRect(0, 0, window.innerWidth, window.innerHeight);


        }
        window.setInterval(() => {
            flies = spawnFlies(flies, 7, GAME.pitchRange);
            flies = flies.filter(f => f.x > 0);
        }, 3000)

        const load = function () {
            pitchdetect = new Monophonics(loop);
            canvasBG.width = window.innerWidth;
            canvasBG.height = window.innerHeight;
            canvasPlayer.width = window.innerWidth;
            canvasPlayer.height = window.innerHeight;
//            ctxPlayer.translate(0, canvasPlayer.height);
//            ctxPlayer.scale(1, -1);
            ////this way ==
            ctxPlayer.font="30px Helvetica";
            ctxPlayer.setTransform(1, 0, 0, -1, 0, canvasPlayer.height);

            //--that way :
            ctxBG.translate(0, canvasBG.height);
            ctxBG.scale(1, -1);

            for (let i = 0; i < necktangles.length; i++) { //copies class but NOT by REFERENCE!! otherwise huge fuckup
                let rect = necktangles[i]
                rect.y = STATE.NECK.startY + rect.numberInChain * rect.h;
                rect.goalY = rect.y;
                rect.color = NumberToHSLa(yToPitch(rect.y, GAME.endY, STATE.NECK.startY, GAME.pitchRange));
                rect.w = rect.w - (5 * rect.numberInChain); //calcRectWidth
                rect.drawMe();
            }
            console.log(necktangles)
//            loop()
        }
        window.addEventListener("resize", function () {
            console.log('asasd')
            canvasBG.width = window.innerWidth;
            canvasBG.height = window.innerHeight;
            canvasPlayer.width = window.innerWidth;
            canvasPlayer.height = window.innerHeight;
            ctxPlayer.setTransform(1, 0, 0, -1, 0, canvasPlayer.height)

        });
        /* UTILITY FUNCTIONS */
        const handleInput = function (inputCode) {
            switch (inputCode) {
                case 49:
                    return 0;

                case 50:
                    return 1;
                case 51:
                    return 2;

                case 52:
                    return 4;

                case 53:
                    return 5;

                case 54:
                    return 6;

                case 55:
                    return 7;

                case 56:
                    return 8;

                case 57:
                    return 9;

                default:
                    return STATE.NECK.endY / 100;
            }

        }

        const drawFly = function (fly, timer = 1, ctx = ctxBG) {
            const wiggle = 15 * Math.sin(timer / 45 * Math.PI) + Math.random() * 2;
            ctx.beginPath();
            ctx.moveTo(fly.x, fly.y + wiggle);
            ctx.lineTo(fly.x + 5, fly.y + wiggle + 5);
            ctx.lineWidth = 10;
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        const spawnFlies = function (flies, maxNumber, pitchRange) {
            const theFlies = flies.slice();
            if (theFlies.length < maxNumber) {
                const atPitch = Math.random() * pitchRange;
                const atY = pitchToY(atPitch)
                theFlies.push({x: window.innerWidth, y: atY})
            }
            return theFlies;
        }

        const isColliding = function (head, fly) {
            const {x, y, w, h} = head;
            const x2 = fly.x;
            const y2 = fly.y;
            const spitlength = 200;
            const spitheight = 50;
            const rect1 = {
                x: x + w / 2 + spitlength,
                y: y - h / 2.3,
            }
            const rect2 = {
                x: x2,
                y: y2
            }
            const isXMatch = (rect1.x - rect2.x > 0 && rect1.x - Math.abs(rect2.x) < spitlength + 10)
            const isYMatch = (Math.abs(rect1.y - rect2.y) < spitheight)

            if (isXMatch && isYMatch) {
                return true;
            }
            else {
                return false;
            }

        }

        function yToPitch(y, endY, startY, pitchR) {
            const units = (endY - startY) / pitchR;
            return (y - startY) / units;
        }

        function pitchToY(pitch) {
            return STATE.NECK.startY + pitch * ((GAME.endY - STATE.NECK.startY) / GAME.pitchRange) //-- one NeckUnit
        }

        const handleMove = function (inputCode) {
            if (inputCode === 68 || inputCode === 39) {
                return 1;
            }
            else if (inputCode === 65 || inputCode === 37) {
                return -1;
            }
            else {
                return 0;
            }
        }

        function NumberToHSLa(number, s = "100%", l = "60%", a = 1) { //HSL is more intuitive then RGB s=100, l =60;
            let num = number;
            if (number > 12) {
                num = number % 12;
            }

            let h = 360 - num * 360 / 12 + 60; //Hue goes gradually around (COUNTERCLOCK) the wheel at pitch '6' => 180deg
            if (h == 360) {
                h = 0;
            }

            return "hsla" + "(" + h + "," + s + "," + l + "," + a + ")";
        }

    </script>
</head>
</body>

