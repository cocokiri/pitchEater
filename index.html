<html>
<body>

</body>
</html>
<body id='bod' onload="load()">

<style>
    body {
        display: flex;
        justify-content: flex-end;
        flex-direction: column-reverse;
    }

</style>
<head>
    <canvas id="canvBG" class="canv"></canvas>
    <canvas id="canvPlayer" class="canv"></canvas>
    <canvas id="canvUI" class="canv"></canvas>
    <canvas id="canvSplinter" class="canv"></canvas>
    <canvas id="canvExplode" class="canv"></canvas>
    <canvas id="canvGoblin" class="canv"></canvas>
    <style type="text/css">
        body {
            margin: 0;
        }

        .canv {
            position: fixed;
            width: 100vw;
            height: 100vh;
            margin: 0px;
            background-color: transparent;
        }

        #canvBG {
            background-color: #000;
            z-index: -1;
        }

        #canvUI {
            z-index: 0;
        }


        #canvPlayer {
            z-index: 1;
        }

        #canvGoblin {
            z-index: 2;
        }
        #canvSplinter {
            z-index: 2;
        }
        #canvExplode {
            z-index: 3;
        }
    </style>

    <script src="./Monophonics.js"></script>
    <script src="./Rects.js"></script>
    <script src="./RacistGoblin.js"></script>
    <script src="./UIBar.js"></script>
    <script src="./Splinter.js"></script>
    <script type="text/javascript">

        var chrome   = navigator.userAgent.indexOf('Chrome') > -1;
        var explorer = navigator.userAgent.indexOf('MSIE') > -1;
        var firefox  = navigator.userAgent.indexOf('Firefox') > -1;
        var safari   = navigator.userAgent.indexOf("Safari") > -1;
        var camino   = navigator.userAgent.indexOf("Camino") > -1;
        var opera    = navigator.userAgent.toLowerCase().indexOf("op") > -1;
        if ((chrome) && (safari)) safari = false;
        if ((chrome) && (opera)) chrome = false;

        //    var isSafari = /constructor/i.test(window.HTMLElement) || (function (p) { return p.toString() === "[object SafariRemoteNotification]"; })(!window['safari'] || safari.pushNotification);

        let mobilecheck = function() {
            var check = false;
            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
            return check;
        };

        let isMobile = mobilecheck();
        if (isMobile) {
            alert("I made this for desktop, but go ahead and try. It might be slow")
        }


        if ( !chrome && !firefox) {
            alert("Made for Chrome or Firefox. NOT WORKING on your browser. I used fancy new audio tech that is too future for most browsers. Try FIREFOX or CHROME")
        }




        /* EVENT LISTENERS */
        const STATE = {
            //fireTimer
            //hasWeaponX
            moving: false,
            moveSpeed: 5,
            playerX: 120,
            fireOn: false,
            loadingFire: false,

            NECK: {
                speed: 6,
                rectCount: 12,
                startY: 200,
                endY: 600
            },
            //health
            //points
            //so 1 unit always equals same pixels
            scaler: window.innerWidth / 100,
        }

        window.addEventListener("keydown", function (ev) {
            if (ev.keyCode === 32) {
                STATE.loadingFire = true;
                console.log(ev.keyCode)
            } else {

                let xDelta = handleMove(ev.keyCode) * STATE.moveSpeed;
                if (xDelta !== 0) {
                    STATE.moving = true;
                    STATE.playerX += 2 * xDelta;
                }
                else {
                    STATE.NECK.endY = STATE.NECK.startY + handleInput(ev.keyCode) * (GAME.endY - STATE.NECK.startY) / 10;
                }
            }

        });

        window.addEventListener("keyup", function (ev) {
            if (ev.keyCode === 32) {
                STATE.loadingFire = false;
                STATE.fireOn = false;
                head.fireTimer = 0;
                head.color = "white"
            }
            if (handleMove(ev.keyCode) !== 0) {
                STATE.moving = false;
            }
        })

        const canvasPlayer = document.getElementById("canvPlayer")
        const canvasSplinter = document.getElementById("canvSplinter")
        const canvasGoblin = document.getElementById("canvGoblin")
        const canvasBG = document.getElementById("canvBG")
        const canvasUI = document.getElementById("canvUI")
        const canvasExplode = document.getElementById("canvExplode")
        const ctxPlayer = canvasPlayer.getContext("2d");
        const ctxGoblin = canvasGoblin.getContext("2d");
        const ctxSplinter = canvasSplinter.getContext("2d");
        const ctxExplode = canvasExplode.getContext("2d");
        const ctxBG = canvasBG.getContext("2d");
        const ctxUI = canvasUI.getContext("2d");
        ctxPlayer.lineCap = "round";
        ctxBG.lineCap = "round";

        /* DECLARATIONS*/
        const GAME = {
            pitchRange: 12,
            FPS: 60,
            endY: window.innerHeight,
            baseMidi: 48,
            currentMidi: 52,
            playerMidi: -59,
            toPlayer: false,
            toGob: true
            //breakNeckSpeed? LLOLOLOL ROFL HELICOPTER ILLUMINATE CONFIRMED HOAX O@2
        };

        let AUDIO_CTX;
        try {
            window.AudioContext = window.AudioContext || // Fix up for prefixing
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.oAudioContext ||
                window.msAudioContext;

            AUDIO_CTX = new AudioContext();
        } catch (e) {
            alert('Web Audio API is not supported in this browser');
        }

        const head = new Head({
            x: 150,
            y: 600,
            w: 90,
            h: 70,
            color: "white",
            mouthHeight: 5
        }, ctxPlayer);

        const body = new Rect({
            numberInChain: 0.5,
            w: 100,
            h: 75,
            color: "white",
            y: 200,
            tick(STATE) {
                const {playerX} = Object.assign({}, STATE);
                const {neckT} = Object.assign({}, STATE.NECK);
                this.x = playerX;
                this.y = neckT[0].y - neckT[0].h / 2.4; //firstNeckBone

                this.drawMe();
            },
            drawMe(ctx = this.ctx) {
                ctx.beginPath();
                const {x, y, w, h} = this;
                ctx.moveTo(x - w / 2, y);
                ctx.lineTo(x + w / 2, y);
                ctx.lineTo(x + w / 5, y - h);
                ctx.lineTo(x - w / 5, y - h);
                ctx.fillStyle = "white";
                ctx.fill();
            }
        }, ctxPlayer);
        const legL = {
            ctx: ctxPlayer,
            w: body.w,
            y: 120,
            h: 120,
            maxh: 120,
            up: true,
            tick(STATE, otherLeg) {
                const {legsY, playerX} = Object.assign({}, STATE);
                this.y = legsY;
                this.x = playerX;

                if (STATE.moving && otherLeg !== undefined) {
                    this.moveWith(otherLeg)
                }
                else if (STATE.moving && otherLeg === undefined) {
                    this.move();
                }
                else {
                    this.h = this.y;
                }
                this.drawMe()
            },
            drawMe(ctx = this.ctx) {
                ctx.beginPath();
                const {x, w, y, h} = this;
                ctx.moveTo(x - w / 2.4, y);
                ctx.lineTo(x, y);
                ctx.lineTo(x - w / 3, y - h);
                ctx.fillStyle = "white";
                ctx.fill();
            },
            moveWith(otherLeg) {
                this.up = !otherLeg.up;
                this.move();
            },
            move() {
                if (this.h < 120) {
                    this.up = false
                }
                else if (this.h > 180) {
                    this.up = true;
                }
                if (this.up) {
                    this.h -= 4 * (this.maxh / (this.h));
                }
                else if (!this.up) {
                    this.h += 2 + Math.random() * 2;
                }
            }
        }

        const legR = Object.assign({}, legL);
        legR.w = legR.w * -1 //direction shift
        const UIBar = new UI(ctxUI);


        const goblin = new RacistGoblin({
            ctx: ctxGoblin,
            audioContext: AUDIO_CTX,
            freq: midiToHz(GAME.baseMidi + 12 + Math.round(Math.random() * 10)) //octave highesome of the 6 lower notes
        });
        let splinter = new Splinter(ctxSplinter);
        splinter.localRotation = 90;
        splinter.w = 40;
        splinter.x = goblin.x - goblin.w / 20;
        splinter.y = goblin.y + goblin.h / 2.1;


        let flies = [{
            x: 500,
            y: 500
        }]

        let timer = 1;
        let necktangles = [];
        necktangles.length = STATE.NECK.rectCount;
        necktangles.fill(1)
        necktangles = necktangles.map((e, i) => new Rect({numberInChain: i}, ctxPlayer))

        /*ACTION*/
        let pitchdetect;
        let roundBuffer = [];
        roundBuffer.length = 10;
        roundBuffer.fill(Math.random())

        const loop = function () {

            if (!GAME.over) {
                requestAnimationFrame(loop);
            }
            timer++;
            ctxPlayer.clearRect(0, 0, window.innerWidth, window.innerHeight);


            /* SOUND STUFF */
            pitchdetect.updateEnergyValues();
            const winnerBin = pitchdetect.normBinIdx;
            const midi = Number(pitchdetect.binToMidi(winnerBin).toFixed(2));
            GAME.currentMidi = midi;
            const pitchHeight = midi - GAME.baseMidi;
            GAME.pitchRel = pitchHeight;
            const silence = -1 - GAME.baseMidi;
            const roundedPitch = Math.round(pitchHeight);
            GAME.note = pitchdetect.midiToNoteName(midi) || ""

//            console.log(midi, pitchdetect.isHarmonic(winnerBin));
           // console.log(roundBuffer, roundedPitch, pitchdetect.isHarmonic(winnerBin))


            const harmonic = pitchdetect.isHarmonic(winnerBin);
            if (harmonic) {
                roundBuffer.push(roundedPitch);
            }
            if (roundBuffer.length > 4) {
                roundBuffer.shift();
            }
            if (roundBuffer.every(e => e === roundedPitch) && roundBuffer[0] !== silence) {
                STATE.loadingFire = true;
                GAME.playerMidi = roundBuffer[0];
            }
            else {
                STATE.loadingFire = false;
                GAME.playerMidi = silence;
                head.fireTimer = 0;
                STATE.fireOn = false;
            }

            if (pitchHeight > 0 && pitchHeight <= GAME.pitchRange) {
                STATE.NECK.endY = pitchToY(pitchHeight)
            }
            // ---------------------------
            if ((GAME.playerMidi % 12 === Math.round(pitchdetect.hzToMidi(goblin.freq)) % 12) && harmonic) { //if goblin and player are the are same octave
                GAME.synced = true;
            }
            else {
                GAME.synced = false;
            }

            if (!GAME.synced && goblin.emerged && GAME.toGob) {
                splinter.moveTowards(necktangles[11], 100)
                    .then(function () {
                        explode(Object.assign({}, head, {w: 50, h: 50})).then(() => alert("YOU LOST"))
                        GAME.over = true;
                    })
                GAME.toGob = false;
                GAME.toPlayer = true;
            }
            else if (GAME.synced && GAME.toPlayer) {
                splinter.moveTowards(goblin, 30)
                    .then(function () {
                        const pos = Object.assign({}, goblin, {y: goblin.y + 200, w: 50, h: 50}) //change y from belly to head
                        explode(pos).then(() => alert("YOU WON"))
                        GAME.over = true;
                    })
                GAME.toGob = true;
                GAME.toPlayer = false;
            }

            if (GAME.over) {
                goblin.osc.disconnect();
            }
//            if (goblin.emerged && !GAME.synced) {
//                splinter.moveTowards(necktangles[11])
//            }


            ctxBG.fillStyle = "hsla(255, 100%, 00%, 0.10)";
//            splinter.moveTowards(head, 3000)

//            goblin.drawMe();


            if (STATE.loadingFire) {
                head.fireTimer++;
            }
            if (head.fireTimer > 30) {
                STATE.fireOn = true;
            }

            necktangles.forEach(rect => rect.tick(STATE))

            STATE.NECK.neckT = necktangles;

            splinter.tick(goblin);
            head.tick(STATE);
            body.tick(STATE);
            goblin.tick();


            const legsY = body.y;
            legL.tick(Object.assign({legsY: legsY}, STATE), undefined);
            legR.tick(Object.assign({legsY: legsY}, STATE), legL);


            flies.forEach((fly, idx) => {
                fly.x = fly.x - 1;
                drawFly(fly, 30 * idx + timer);
                if (STATE.fireOn) {
                    if (isColliding(head, fly)) {
                        fly.isDead = true;

                        UIBar.addPoint()
                        if (UIBar.userData.points % 5 === 0) {
                            goblin.emerge();
                        }
                        ctxBG.fillStyle = "white";

                        flies = flies.filter(fly => !fly.isDead)
                    }
                }
            })
            //this is later in the loop for user to notice
            ctxBG.fillRect(0, 0, window.innerWidth, window.innerHeight);


        }

        function explode(origin = {x: 400, y: 400, h: 60, w: 60}, ctx = ctxExplode) {
            window.clearInterval(window.expl)
            let {x, y, w, h} = origin;
            let center = {x: x + w / 2, y: y + h / 2}
            return new Promise(function (resolve, rej) {
                let counter = 0;
                window.expl = window.setInterval(function () {
                    ctx.save();

                    ctx.translate(center.x, center.y)
                    ctx.rotate((Math.random() * 360 - 90) * Math.PI / 180)
                    ctx.translate(-center.x, -center.y)

                    ctx.beginPath()
                    ctx.strokeStyle = 'white'
                    ctx.strokeWidth = 10;

                    ctx.fillStyle = 'rgba(0,0,0,0.9)'
                    ctx.fillRect(center.x, center.y, w, h);
                    ctx.rect(center.x, center.y, w, h);
                    ctx.stroke();
                    ctx.closePath();

                    ctx.restore();

                    center.y -= 3;
                    h += 0.5;
                    w += 0.5;
                    counter++;

                    if (counter > 120) {
                        resolve();
                        window.clearInterval(window.expl)
                    }

                }, 30)
            })

        }

        window.setInterval(() => {
            flies = spawnFlies(flies, 7, GAME.pitchRange);
            flies = flies.filter(f => f.x > 0);
        }, 3000)

        const load = function () {
            pitchdetect = new Monophonics(loop); //callback after permission granted = loop

            canvasBG.width = window.innerWidth;
            canvasBG.height = window.innerHeight;
            canvasExplode.width = window.innerWidth;
            canvasExplode.height = window.innerHeight;
            canvasPlayer.width = window.innerWidth;
            canvasSplinter.height = window.innerHeight;
            canvasSplinter.width = window.innerWidth;
            canvasGoblin.height = window.innerHeight;
            canvasGoblin.width = window.innerWidth;
            canvasPlayer.height = window.innerHeight;
            canvasUI.width = window.innerWidth;
            canvasUI.height = window.innerHeight;
//            ctxPlayer.translate(0, canvasPlayer.height);
//            ctxPlayer.scale(1, -1);
            ////this way ==

            ctxPlayer.setTransform(1, 0, 0, -1, 0, canvasPlayer.height);
            ctxSplinter.setTransform(1, 0, 0, -1, 0, canvasPlayer.height);
            ctxGoblin.setTransform(1, 0, 0, -1, 0, canvasPlayer.height);
            ctxUI.setTransform(1, 0, 0, -1, 0, canvasUI.height);
            ctxExplode.setTransform(1, 0, 0, -1, 0, canvasPlayer.height);

            ctxPlayer.font = "30px Helvetica";

            window.setTimeout(function() {
//                goblin.emerge();

            }, 3000)

            //--that way :
            ctxBG.translate(0, canvasBG.height);
            ctxBG.scale(1, -1);

            UIBar.drawMe();
//            goblin.drawMe();

            for (let i = 0; i < necktangles.length; i++) { //copies class but NOT by REFERENCE!! otherwise huge fuckup
                let rect = necktangles[i]
                rect.y = STATE.NECK.startY + rect.numberInChain * rect.h;
                rect.goalY = rect.y;
                rect.color = NumberToHSLa(yToPitch(rect.y, GAME.endY, STATE.NECK.startY, GAME.pitchRange));
                rect.w = rect.w - (4 * rect.numberInChain); //calcRectWidth
                rect.drawMe();
            }
            console.log(necktangles)
//            loop()
        }
        //        window.addEventListener("resize", function () {
        //            console.log('asasd')
        //            canvasBG.width = window.innerWidth;
        //            canvasBG.height = window.innerHeight;
        //            canvasPlayer.width = window.innerWidth;
        //            canvasPlayer.height = window.innerHeight;
        //            ctxPlayer.setTransform(1, 0, 0, -1, 0, canvasPlayer.height)
        //
        //        });
        /* UTILITY FUNCTIONS */


        const handleInput = function (inputCode) {
            switch (inputCode) {
                case 49:
                    return 0;

                case 50:
                    return 1;
                case 51:
                    return 2;

                case 52:
                    return 4;

                case 53:
                    return 5;

                case 54:
                    return 6;

                case 55:
                    return 7;

                case 56:
                    return 8;

                case 57:
                    return 9;

                default:
                    return STATE.NECK.endY / 100;
            }

        }

        const drawFly = function (fly, timer = 1, ctx = ctxBG) {
            const wiggle = 15 * Math.sin(timer / 45 * Math.PI) + Math.random() * 2;
            ctx.beginPath();
            ctx.moveTo(fly.x, fly.y + wiggle);
            ctx.lineTo(fly.x + 5, fly.y + wiggle + 5);
            ctx.lineWidth = 10;
            ctx.strokeStyle = "white";
            ctx.stroke();
        }

        const spawnFlies = function (flies, maxNumber, pitchRange) {
            const theFlies = flies.slice();
            if (theFlies.length < maxNumber) {
                const atPitch = Math.random() * pitchRange;
                const atY = pitchToY(atPitch)
                theFlies.push({x: window.innerWidth, y: atY})
            }
            return theFlies;
        }

        const isColliding = function (head, fly) {
            const {x, y, w, h} = head;
            const x2 = fly.x;
            const y2 = fly.y;
            const spitlength = 200;
            const spitheight = 50;
            const rect1 = {
                x: x + w / 2 + spitlength,
                y: y - h / 2.3,
            }
            const rect2 = {
                x: x2,
                y: y2
            }
            const isXMatch = (rect1.x - rect2.x > 0 && rect1.x - Math.abs(rect2.x) < spitlength + 10)
            const isYMatch = (Math.abs(rect1.y - rect2.y) < spitheight)

            if (isXMatch && isYMatch) {
                return true;
            }
            else {
                return false;
            }

        }

        function yToPitch(y, endY, startY, pitchR) {
            const units = (endY - startY) / pitchR;
            return (y - startY) / units;
        }

        function pitchToY(pitch) {
            return STATE.NECK.startY + pitch * ((GAME.endY - STATE.NECK.startY) / GAME.pitchRange) //-- one NeckUnit
        }

        const handleMove = function (inputCode) {
            if (inputCode === 68 || inputCode === 39) {
                return 1;
            }
            else if (inputCode === 65 || inputCode === 37) {
                return -1;
            }
            else {
                return 0;
            }
        }
        function midiToHz(midi) {
            let base = 8.1757989156; //Midi 0 according to: "THE INTERNET"
            let totalOctaves = 10; //from midi 0 to midi 120
            let multiplier = Math.pow(2, totalOctaves * midi / 120); //genius! forgot why
            let frequency = base * multiplier; // in HZ
            return frequency;
        }

        function NumberToHSLa(number, s = "100%", l = "60%", a = 1) { //HSL is more intuitive then RGB s=100, l =60;
            let num = number;
            if (number > 12) {
                num = number % 12;
            }

            let h = 360 - num * 360 / 12 + 60; //Hue goes gradually around (COUNTERCLOCK) the wheel at pitch '6' => 180deg
            if (h == 360) {
                h = 0;
            }

            return "hsla" + "(" + h + "," + s + "," + l + "," + a + ")";
        }

    </script>
</head>
</body>

