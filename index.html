<html>
<body>

</body>
</html>
<body id='bod' onload="load()">

<style>
    body {
        display: flex;
        justify-content: flex-end;
        flex-direction: column-reverse;
    }

</style>
<head>
    <canvas id="canvBG"></canvas>
    <canvas id="canvPlayer"></canvas>
    <style type="text/css">
        body {
            margin: 0;
        }

        #canvBG {
            background-color: #000;
            z-index: -1;
            position: fixed;
            width: 100vw;
            height: 100vh;
            margin: 0px;
        }

        #canvPlayer {
            background-color: transparent;
            z-index: 0;
            position: fixed;
            width: 100vw;
            height: 100vh;
        }


    </style>
    <script type="text/javascript">


        const GAME = {
            pitchRange: 5,
            FPS: 60,

            neckSpeed: 6,
            neckParts: 10
            //breakNeckSpeed? LLOLOLOL ROFL HELICOPTER ILLUMINATE CONFIRMED HOAX O@2
        }

        const NECK = {
            speed: 6,
            rectCount: 10,
            startY: 200,
            endY: 600
        }

        const player = {
            head: {
                //x y
            }
        }

        flies = []

        //BG
        //fade over BG
        //flies --x pos


        //PLAYER
        //calc Y of all rectangles (bones)
        //keyboard events
        //draw

        //  grow
        //shrink
        //fluctuating timer 1s


        //hardcode 12 neck Rects?
        //dynamically adjust maxrects for pitchrange

        const Rect = class {
            constructor() {
                //there is no startY ... set that were you use the class
                this.numberInChain = 1 //1 = 1st from the bottom going up
                this.percY = 1; //1 = 100% = top of the chain
                this.y = 200;
                this.goalY = 200;
                this.w = 100;
                this.h = 20;
                this.color = "red";
            }
            setGoalY(refY, partsInChain) {
                const percY = this.numberInChain / partsInChain;
                this.goalY = refY * percY;
                return this.goalY;
            }
            adjustY(inSteps) { //will approach, but not reach...abschwaechende curve
                const delta = this.goalY - this.y; //linear: exchange currentY here with memory of y when it started
                this.y += delta/inSteps;
                return this.y;
            }
        }

        //TODO deltaY -> /divide by timesteps

        const playerX = 150;

        const rect = new Rect();
        const f = [];

        //TODO abstract value giver FN

        const drawRect = function (rect, ctx, x=playerX, padding=0.7) { //delay this ...sequence matters. If (isGoingUp) else resize height &y dynamically except non-neck rectangles
            const r = Object.assign({}, rect) //only properties
            ctx.beginPath();
            ctx.fillStyle = r.color;
            ctx.rect(
                x,
                r.y,
                r.w,
                r.h * padding
            )
            ctx.fill();
        }

        //numberToHSLa


        //        const resizeCanvas() {}
        //        for (let rect of neckRects) {
        //            rect.y =
        //        }

        const loop = function () {
            requestAnimationFrame(loop);

            ctxPlayer.clearRect(0,0, window.innerWidth, window.innerHeight)
            for (let rect of f) {
                rect.setGoalY(NECK.endY, NECK.rectCount)
                rect.adjustY(10)
                drawRect(rect, ctxPlayer)

            }
        }

        const canvasPlayer = document.getElementById("canvPlayer")
        const canvasBG = document.getElementById("canvBG")
        const ctxPlayer = canvasPlayer.getContext("2d");
        const ctxBG = canvasBG.getContext("2d");


        function load() {

            canvasBG.width = window.innerWidth;
            canvasBG.height = window.innerHeight;
            canvasPlayer.width = window.innerWidth;
            canvasPlayer.height = window.innerHeight;
            ctxPlayer.translate(0, canvasPlayer.height);
            ctxPlayer.scale(1, -1);
            ctxBG.translate(0, canvasBG.height);
            ctxBG.scale(1, -1);

            ctxPlayer.fillStyle = 'white';
            ctxPlayer.rect(0, 0, 100, 100)
            ctxPlayer.fill()


            for (let i = 0; i < NECK.rectCount; i++) { //copies class but NOT by REFERENCE!! otherwise huge fuckup
                f[i] = new Rect();
                f[i].numberInChain = i;
                f[i].y = NECK.startY + i * f[i].h;
                f[i].goalY = f[i].y;
                drawRect(f[i], ctxPlayer)
            }


            loop()
        }

        const handleInput = function (inputCode) {
            switch (inputCode) {
                case 49:
                    return 1;

                case 50:
                    return 2;
                case 51:
                    return 3;

                case 52:
                    return 4;

                case 53:
                    return 5;

                case 54:
                    return 6;

                case 55:
                    return 7;

                case 56:
                    return 8;

                case 57:
                    return 9;

                default:
                    return 5;
            }

        }

        window.addEventListener("keydown", function (ev) {
            console.log(ev.keyCode)
            NECK.endY = handleInput(ev.keyCode) * 100;
        })

        //        const calcKinetics = function (sR, number) {
        //            const c = Object.assign({}, sR); // != (sR, {})
        //            return Object.assign(c, {nr: number, y: number * c.h}) //2nd overwrites first;
        //        }
    </script>
</head>
</body>

